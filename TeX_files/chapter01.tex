\chapter{Introduction}


\section{What is Mercury?}

Mercury\footnote{\url{https://mercurylang.org}} is a \textit{functional logic} programming language, which is a paradigm that combines features common in certain functional languages (e.g. higher-order constructs, strong advanced typing) and logic programming semantics (e.g. non-determinism, built-in search). It attempts to combine the clarity and expressiveness of declarative programming with advanced static analysis and error detection features. According to its creators, it's a ``general purpose language intended to support the creation of large, reliable and efficient applications.'' Although a short-lived renewed interest in this paradigm has been generated by Epic Games's programming language Verse\footnote{\url{https://dev.epicgames.com/documentation/en-us/fortnite/verse-language-reference}} a few years earlier, it has now seemingly died down unfortunately; the paradigm remains interesting regardless, for the obvious reason that it provides extra edge against both purely functional and purely logic languages.

As are most of the languages that are of similar categories, Mercury has been mostly used for academic/research purposes, but a few commercial products have chosen (or once chosen) Mercury as their main language as well, like PrinceXML\footnote{\url{https://www.princexml.com}}, which is an HTML rendering tool used in publishing.

\subsection{Other similar languages}

A few languages have been said to be similar to Mercury on its different aspects:

\begin{itemize}
\item Curry\footnote{\url{https://curry-lang.org}}: When discussing functional logic programming, people naturally lean towards a conceptual Haskell-Prolog continuum; if one were to say Mercury is closer to the Prolog side, Curry is clearly closer to the Haskell side of things.
\item Clean\footnote{\url{https://clean-lang.org}}: Clean is the lesser-known sibling of Haskell famed for its uniqueness typing. It was said that the ability to explicitly specify uniqueness is not unlike that of Mercury.
\end{itemize}


\section{The state of things as of now}

Mercury has been considered a difficult language to learn, even for people who has previous functional language experiences. While Mercury do have unfamiliar aspects from the viewpoint of programmers who have only written in ``conventional'' languages like Scala or Haskell, I personally find those aspects aren't as difficult as one may think; I believe, that to a certain point this ``difficult'' feel comes from other factors, like the lack of a visible software ecosystem:

\begin{itemize}
\item Lack of example, tutorials and other introductory text: To be honest, it's not that we don't \textit{have} those, it's simply that most of them tend to be slightly too confusing for common programmers who are used to conventional imperative/functional languages. As of the time of writing (October 2025), we have the following attempts:
  \begin{itemize}
  \item The tutorial written by Ralph Becket which is listed on Mercury's official website\footnote{\url{https://mercurylang.org/documentation/learning.html}}. Unfortunately this tutorial was left unfinished years ago and its author was said to have since stopped doing Mercury-related things.
    \item The tutorials on Mercury's GitHub repository wiki\footnote{\url{https://github.com/Mercury-Language/mercury/wiki/Tutorial}}, which seemingly has ceased major activities since 2018.
    \item ``Learn Mercury By Y Minute''\footnote{\url{https://learnxinyminutes.com/mercury/}}, which didn't do a very good job at explaining things to a depth a learner would need their materials to have.
    \item ``Mercury Crash Course'' written by J Fondren, on the now-defunct mercury-in.space website\footnote{You can still read it on Wayback Machine: \url{https://web.archive.org/web/20220815044519/https://mercury-in.space/crash.html}}, which honestly was too confusing for newcomers to provide any help.
      \item A book titled ``Declarative Programming in Mercury'' is also available by compiling from the TeX source yourself using the source code\footnote{Available on GitHub: \url{https://github.com/Mercury-Language/books/tree/master/decl_prog}}, but this one really isn't an introductory text...
    \end{itemize}
\item Lack of package manager: Same as above, it's not like we \textit{don't} have one - in fact we have two, one called Merchant by Stewart Slocum\footnote{\url{https://github.com/stewy33/merchant}}, and one called \texttt{mmc-get}\footnote{\url{https://github.com/jrfondren/mmc-get}} by J Fondren, which used to have a handful of packages\footnote{\url{https://web.archive.org/web/20221130042103/https://mercury-in.space/packages/packages.list}}. They are not compatible with each other (of course), which I doubt have ever created any kind of problem since nearly no one used them. 
\item Lack of libraries: This is the real pain point. If a language did not have enough libraries, people are much less likely to use the language to make things; and if not enough people are using the language, there wouldn't be enough demand and thus there wouldn't be enough libraries. It's a viscious cycle that requires a \textit{lot} of effort to break.
  
\end{itemize}

But all of these situations won't change if we simply do nothing and hope for that one dumbass to put their love and effort for little to none rewards, which is why I have decided to become that dumbass myself and write this book to bridge the gap somewhat.

\section{Who's this book for}

This book is for programmers who have previous experiences with imperative/functional languages who knows how programming works in principle and are used to filling in the details which could've been thought as incomplete or even missing. While learning Mercury as your first programming language might be a fun experiment to run on yourself, as the state of things being they are right now, it's just a little too much to be truly beginner-friendly, so I can't say I recommend it. Maybe years later when we have as much things as Haskell, this option would be viable again.

\section{The tool we will be using}

As of now (October 2025) there is only one implementation of Mercury: the Melbourne Mercury Compiler. All code in this book has been tested against version 22.01.8. Installing the compiler is probably one of the most painful part: since there is no official prebuilt binaries, you will have to download the source code, compile it and install it yourself. If you're using an operating system with a package manager (like most Linuxes), their package repositories might have packages that ease the complexity of managing a little bit, but the package might simply be a automated build instructions without any pre-built binaries and your machine still needs to build the compiler, which takes a very long time.

Strangely, for the Melbourne Mercury Compiler, I actually recommend you to build from the source code instead of relying on the package repository available: MMC contains different backends and configurations called ``grades'' and is actually capable of generating code for Java and C#:

\begin{quote}
  \texttt{-s \textit{grade}}\\
  \texttt{--grade \textit{grade}}
  
  Select the compilation model. This model, which Mercury calls a grade, specifies what properties the resulting executable or library should have. Properties such as `\texttt{generates profiling data for mprof when executed}' and `\texttt{can be debugged with the Mercury debugger}'. As such, it controls decisions that must be made the same way in all the modules of a program.

  \textit{--- From the man page of \texttt{mmc}}
\end{quote}

Certain things also requires a separate ``grade'' being available (e.g. weirdly, single-precision floating point numbers; see the section about basic types in Chapter 3). The package in the package repository of your operating system might not be configured with the grades you're interested in enabled.

\section{More importantly... \textit{why?}}

A standard answer to this question would be ``why not?''\footnote{But seriously, if you've got the time, \textit{why not?}}, but I believe that people who would ask would like a different answer. The biggest appeal of Mercury, I think, is probably its ability to provide the power of both functional and logic programming in a rigorous way that can support developments of large-scale projects, much like having a static type system has been proven to be helpful (at least to certain degree) in this regard -- before this, most logic programming languages either don't have the static checks Mercury do or were only really suitable for academic purposes. You may argue that you don't need all those and can still do everything with conventional languages like C; I will give you the win since I have no arguments against that, but can you truly convince yourself that that's a good argument?


%%% Local Variables:
%%% mode: LaTeX
%%% TeX-master: "../main"
%%% End:
