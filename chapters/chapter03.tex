\chapter{Programming in Mercury}

\section{Trace Goals}

Before we continue we must talk about how to explore things on one's own. A common strategy of debugging in conventional languages would be to insert printing statements at places where one would expect the program to reach with its state containing certain values; this strategy doesn't work well with Mercury, since to perform IO in Mercury you would need to do it through \texttt{io.state}, which naturally has the implication of spreading out and forcing everything that uses the predicate to adopt two extra \texttt{io.state} parameters.\footnote{Which is not unlike the famous ``color of function'' problem in languages with \texttt{async} (e.g. JavaScript)}

For example, assume we have the following program that prints out the factorial of 5:

\begin{lstlisting}[language=Mercury]
:- module ex01.
:- interface.
:- import_module io.
:- pred main(io.state::di, io.state::uo) is det.
:- implementation.

:- import_module int.

:- pred fac(int, int).
:- mode fac(in, out) is det.
fac(N, M) :-
	( if ( N = 0 ) then ( M = 1 )
	  else if ( N = 1 ) then ( M = 1 )
	  else if ( N < 0 ) then ( M = 1 )
	  else ( fac(N-1, M1), M = N * M1 )
	)
.

main(!IO) :-
    io.write_string("Hello, world!\n", !IO),
	fac(5, M),
	io.write_int(M, !IO).
\end{lstlisting}

Let's say we want to add a printing goal in \texttt{fac}. Printing, naturally, requires two \texttt{io.state} just like we've been mentioning. If we do it by adding \texttt{io.state}, we need to perform the following changes:

\begin{itemize}
\item Change the \texttt{pred} line into \texttt{:- pred fac(int, int, io.state, io.state)};
\item Change the \texttt{mode} line in a similar fashion;
\item Change every occurence of \texttt{fac} accordingly;
\item Since for every call site of \texttt{fac} we now need to pass two extra \texttt{io.state} arguments, the environment surrounding the call site should have those extra arguments ready;
  \begin{itemize}
  \item and for some predicates this could mean adding extra parameters just like what we've done to \texttt{fac};
  \item and now the call sites of \textit{those} predicates also need to have their signature changed, and this change would also affect call sites that calls \textit{them}, and the need of change would thus propagate upwards...
  \end{itemize}

  \item ...and after the debugging is done, we need to change them \textit{back}.
\end{itemize}

This kind of coding process not only goes against the spirit of Mercury but is also just extremely tedious. Luckily, for this Mercury prepared a feature called \textbf{trace goals}.

Trace goals in Mercury are of the format \texttt{trace \lbrack\textit{param1, ...}\rbrack  \;\texttt{Goal}}. In such a goal, all variables bound in the parameter list part is available within the \texttt{\textit{Goal}} part. There are many different parameters that one can use, but the most common is probably going to be \texttt{io}; by having \texttt{io(!IO)} which bound a pair of \texttt{io.state} to the state variable of your choice, you can use it to display debug messages in \texttt{\textit{Goal}} freely without having to do the changes listed above. For example, assume we want our program to display the value of each call to \texttt{fac} before they return, we can add a trace goal that introduces a pair of \texttt{io.state} arguments like this:

\begin{lstlisting}[language=Mercury]
:- module ex01.
:- interface.
:- import_module io.
:- pred main(io.state::di, io.state::uo) is det.
:- implementation.

:- import_module int.

:- pred fac(int, int).
:- mode fac(in, out) is det.
fac(N, M) :-
	( if ( N = 0 ) then ( M = 1 )
	  else if ( N = 1 ) then ( M = 1 )
	  else if ( N < 0 ) then ( M = 1 )
	  else ( fac(N-1, M1), M = N * M1 )
	),
	trace [ io(!IO) ] (
		io.write_string("fac(", !IO),
		io.write_int(N, !IO),
		io.write_string(") = ", !IO),
		io.write_int(M, !IO),
		io.write_string("\n", !IO)
	)
.

main(!IO) :-
    io.write_string("Hello, world!\n", !IO),
	fac(5, M),
	io.write_int(M, !IO).
\end{lstlisting}

Notice that without changing the signatures of \texttt{fac} we can still obtain \texttt{io.state} and display things.

\section{Using the standard library}

As you read through the documentation of Mercury's standard libraries\footnote{Available at \url{https://mercurylang.org/information/doc-release/mercury_library/index.html} and \url{https://mercurylang.org/information/doc-latest/mercury_library_manual/index.html}, for latest stable and latest nightly, respectively.}, you'll see the notice saying that ``we recommend that if possible you use only those modules whose stability is described as either `medium to high' or `high''', you'll see a \texttt{stability} declaration in each of the documentation page, and you'll see that certain modules that \textit{should} be stable, like \texttt{int} and \texttt{uint}, has a stability of \texttt{low}; should you rely on these modules that are of low stability? Sometimes the answer is yes -- these modules have reached \texttt{high} stability in the latest nightly, which means that the interface of these modules, as it's described in the documentation of latest nightly, shouldn't change so much that it breaks basic programs in the future, and thus should be safe to use. In general, my recommendation is to read the documentation for the latest nightly when you're not sure if you can still use the same library predicate when the next major release come out.

\section{Basic Datatypes}

Finally, after all that build-up, we can look at the basic datatypes.

\subsection{Signed and unsigned integers}

In Mercury, the types of signed integers are: \texttt{int}, \texttt{int8}, \texttt{int16}, \texttt{int32} and \texttt{int64}, and the types of unsigned integers are: \texttt{uint}, \texttt{uint8}, \texttt{uint16}, \texttt{uint32} and \texttt{uint64}. The types with a number suffix are exactly what you think they are, e.g. \texttt{int8} means an 8-bit signed integer, etc.. The length of \texttt{int} is said to be ``implementation-defined'' but at least 32 bits. If you want to know how long an \texttt{int} actually is, you can have the following program:

\begin{lstlisting}[language=Mercury]
:- module ex01.

:- interface.

:- use_module io.
:- pred main(io.state::di, io.state::uo) is det.

:- implementation.
:- import_module int, string.


main(!IO) :-
    int.bits_per_int(BPI),
	string.int_to_string(BPI, BPIStr),
	io.write_string(BPIStr, !IO),
	io.write_string("\n", !IO).
\end{lstlisting}


As of now (October 2025), to enable the arithmetic and comparing operations of these types you must import the corresponding module, e.g. to be able to compare \texttt{uint} you must import the \texttt{uint} module. Actually, as a rule of thumb, if you need to do stuff with any of these types (and the basic types described in sections below), it's good measure to import the corresponding module even if you ended up not needing them.

\subsubsection{Syntax of integers}

A decimal integer is any sequence of decimal digits. Unlike in some languages, having the prefix \texttt{0} doesn't make it octal. In Mercury, the corresponding prefixes for non-decimal integers are: \texttt{0b} for binary, \texttt{0o} for octal, and \texttt{0x} for hexadecimal. Mercury also supports a prefix of \texttt{0'} followed by any single character; this would result in the character code that character has. (Note that the character immediately after the single quote is considered part of the integer literal regardless of its common usage in other parts of Mercury code; e.g. to get the character code of the character \texttt{,} you write \texttt{0',} with no extra measure of escaping. This works for Unicode characters as well; see the example below.)

A suffix may also be present, with different suffixes and their meanings listed as follows:
\begin{center}
  \begin{tabular}{|c|c|}
    \hline
    Suffix & Type \\
    \hline
i or no suffix & Signed (\texttt{int})  \\
i8 & Signed 8-bit (\texttt{int8})  \\
i16 & Signed 16-bit (\texttt{int16})  \\
i32 & Signed 32-bit (\texttt{int32})  \\
i64 & Signed 64-bit (\texttt{int64})  \\
u & Unsigned (\texttt{uint}) \\
u8 & Unsigned 8-bit (\texttt{uint8}) \\
u16 & Unsigned 16-bit (\texttt{uint16}) \\
u32 & Unsigned 32-bit (\texttt{uint32}) \\
u64 & Unsigned 64-bit (\texttt{uint64}) \\
\hline
  \end{tabular}
  \end{center}

  An arbitrary number of underscore \texttt{\_} can be inserted between the radix prefix and the first digit (e.g. \texttt{0x\_123}), between the digits (e.g. \texttt{0b\_0001\_0011}, and between the last digit and the type suffix (e.g. \texttt{0b10010011\_u8}. Inserting underscores do not affect the actual value.

  An example program showcasing the syntax for integers is listed as follows.\footnote{As you can see, sometimes some lexers cannot properly handle valid Mercury code...}

\begin{lstlisting}[language=Mercury]
:- module ex01.

:- interface.

:- use_module io.
:- pred main(io.state::di, io.state::uo) is det.

:- implementation.
:- import_module string.
:- import_module int, int8, int16, int32, int64.
:- import_module uint, uint8, uint16, uint32, uint64.

main(!IO) :-
	io.write_string(string.int_to_string(32i) ++ "\n", !IO),
	io.write_string(string.int8_to_string(32i8) ++ "\n", !IO),
	io.write_string(string.int16_to_string(32i16) ++ "\n", !IO),
	io.write_string(string.int32_to_string(32i32) ++ "\n", !IO),
	io.write_string(string.int64_to_string(32i64) ++ "\n", !IO),
	io.write_string(string.uint_to_string(32u) ++ "\n", !IO),
	io.write_string(string.uint8_to_string(32u8) ++ "\n", !IO),
	io.write_string(string.uint16_to_string(32u16) ++ "\n", !IO),
	io.write_string(string.uint32_to_string(32u32) ++ "\n", !IO),
	io.write_string(string.uint64_to_string(32u64) ++ "\n", !IO),
	io.write_string("\n", !IO),
	io.write_string(string.uint_to_string(0x_123u) ++ "\n", !IO),
	io.write_string(string.uint_to_string(0b_0001_0011u) ++ "\n", !IO),
	io.write_string(string.uint8_to_string(0b0001_0011_u8) ++ "\n", !IO),
	io.write_string(string.int_to_string(0'K) ++ "\n", !IO),
	io.write_string(string.int_to_string(0'å˜¿) ++ "\n", !IO),
	io.write_string(string.int_to_string(0',) ++ "\n", !IO),
	io.write_string(string.int_to_string(0':) ++ "\n", !IO).
\end{lstlisting}

\subsection{Floating-point numbers}

In Mercury, there is only one type of floating-point number: \texttt{float}. As of now (October 2025; MMC 22.01.8), the default size of this type is double-precision (i.e. 64 bits). Single-precision can be enabled by using the \texttt{.spf} grade suffix, which means to use the command line argument \texttt{--grade asm\_fast.gc.spf} or \texttt{--grade hlc.gc.spf} or others while compiling, depending on which backend you want to use. \texttt{.spf} isn't always available; if your call to \texttt{mmc} results in an error like this one:

\begin{lstlisting}
mercury_compile: error: the Mercury standard library cannot be found in grade
  `asm_fast.gc.spf'.
\end{lstlisting}

It means that this particular configuration of backend isn't installed and is thus unavailable. This is likely to be the case, since the default configuration does not include \texttt{.spf} grades.

\subsection{Character and string}

In Mercury, the character type is \texttt{char} and the string type is \texttt{string}.


\subsubsection{Syntax of string}

Strings in Mercury are enclosed in double-quotes \texttt{"}. A few escape sequences are supported:


\begin{center}
  \begin{tabular}{|c|c|c|}
    \hline
    Escape sequence & Meaning & Example \\
    \hline
    \texttt{\textbackslash \textbackslash} & Backslash \texttt{\textbackslash} & \texttt{\textbackslash \textbackslash}\\
    \texttt{\textbackslash '} & Single quote & \texttt{\textbackslash '}\\
    \texttt{\textbackslash "} & Double quote & \texttt{\textbackslash "}\\
\texttt{\textbackslash a} & Beep & \texttt{\textbackslash a}\\
\texttt{\textbackslash b} & Backspace & \texttt{\textbackslash b}\\
\texttt{\textbackslash r} & Carriage return & \texttt{\textbackslash r}\\
\texttt{\textbackslash f} & Form feed & \texttt{\textbackslash f}\\
\texttt{\textbackslash t} & Tab & \texttt{\textbackslash t}\\
\texttt{\textbackslash n} & Newline & \texttt{\textbackslash n}\\
\texttt{\textbackslash v} & Vertical tab & \texttt{\textbackslash v}\\
    \texttt{\textbackslash xXX\textbackslash} & Hexadecimal escape & \texttt{\textbackslash x37\textbackslash}\\
    \texttt{\textbackslash XXX\textbackslash} & Octal escape & \texttt{\textbackslash 037\textbackslash}\\
\texttt{\textbackslash uXXXX} & Unicode & \texttt{\textbackslash u3707} \\
\texttt{\textbackslash UXXXXXXXX} & Unicode & \texttt{\textbackslash U00003707} \\
    \hline
  \end{tabular}
\end{center}

The length of a hexadecimal or an octal escape sequence is not pre-determined (viz. there can be 2, 3, 4 or potentially more hexadecimal/octal digits that comes after a \texttt{\textbackslash x}/\texttt{\textbackslash} prefix); but if the escaped value turned out to be invalid (e.g. a very big number that goes over the Unicode range), a compile error would occur.

The ending backslash for a hexadecimal/octal escape sequence is necessary. For example, this small program:

\begin{lstlisting}[language=Mercury]
:- module ex01.

:- interface.

:- use_module io.
:- pred main(io.state::di, io.state::uo) is det.

:- implementation.

main(!IO) :-
	io__write_string("\x4b\\\\n", !IO),
	io__write_string("\x4b\\\n", !IO).
\end{lstlisting}

...prints two lines of text: \texttt{K\textbackslash} and \texttt{K\textbackslash n}, with the second line \textit{not} ending in a newline character. This is because the first string is being read as the combination of \texttt{\textbackslash x4b\textbackslash}, \texttt{\textbackslash\textbackslash} and \texttt{\textbackslash n}, but the second string is being read as the combination of \texttt{\textbackslash x4b\textbackslash}, \texttt{\textbackslash\textbackslash} and \texttt{n}.

Other than \texttt{\textbackslash "}, you can also use \texttt{""} to represent one single double-quote character within a string.

Multi-line string literals are also possible by having a single backslash at the end of the line; the backslash character and the newline character after it would be ignored. Unlike some languages, you need to insert newline manually; for example, the first call of the following would only produce \textit{one} single line of output:

\begin{lstlisting}[language=Mercury]
    % ...
	io__write_string("a\
    multi\
        line\
            string\
                literal\
", !IO),
	io__write_string("a\n\
    multi\n\
        line\n\
            string\n\
                literal\n\
", !IO),
    % ...
\end{lstlisting}


\subsubsection{Syntax of character}

The syntax of character is slightly trickier to describe. In many languages, characters are quoted with single-quote \texttt{'}; but per Prolog tradition, single-quotes are also for atoms (or \textit{names}, as defined in Mercury's language manual), which may contain more than one character. Currently, it seems like that Mercury treats quoted names containing one single character (or escape sequence) as character literals under the right context.

One needs to be careful when using quoted atoms when they intend to write character literals: if a character is an operator, simply quoting it isn't enough, since Mercury considers single-quoted operators are still operators themselves. To prevent such cases from being interpreted as an operation of values, one should surround the quoted name with parentheses. For example, \texttt{Char = '+'} is syntatically invalid, since it's being interpreted as \texttt{Char = +}; one should write \texttt{Char = ('+')} in this case.

\subsection{Tuples}

Mercury supports using N-tuple for any N larger than or equal to zero. In Mercury, tuples are enclosed with braces \texttt{\{\}} both for types and for values. See the example below:

\begin{lstlisting}[language=Mercury]
:- module ex01.

:- interface.

:- use_module io.
:- pred main(io.state::di, io.state::uo) is det.

:- implementation.
:- import_module int, string.

:- pred f1({int, string}::in, {string, int}::out) is det.
f1({X, Y}, {Y, X}).

main(!IO) :-
    % bind X to a tuple value.
	X = {3, "abc"},

    % get a reversed tuple w/ f1 (defined above).
	f1(X, Reversed_X),

    % break the reversed tuple down into different values.
	{MyString, MyInteger} = Reversed_X,
	io.write_string(string.int_to_string(MyInteger) ++ ", " ++ MyString ++ "\n", !IO).
\end{lstlisting}

\subsection{Maybe}

The \texttt{maybe} datatype

\subsection{Universal type}

In Mercury, this type (named \texttt{univ}) is simply a type that can be used to contain any value, similar to \texttt{Object} in Java for objects. It is sometimes used to produce values that need to be able to have different types; for example, the \texttt{list} type in Mercury is homogeneous (i.e. its elements must be of the same type), so one way to achieve heterogeneous lists is to convert all the values of different types into \texttt{univ} type and have a value of \texttt{list(univ)}.

Two main predicates have been provided in the \texttt{univ} module: \texttt{type_to_univ/2} and \texttt{univ_to_type/2}, which converts value into \texttt{univ} and converts \texttt{univ} into other types of values respectively. A function \texttt{univ/1} is also defined to have the same effect of predicate \texttt{type_to_univ/2}, which also probably get used more often.

Converting from \texttt{univ} to other types needs extra caution; since you don't know what the underlying type of an \texttt{univ} actually is during compile time, any such conversion could have a chance of failure. The predicate \texttt{univ_to_type/2} is thus naturally of determinism \texttt{semidet}. You can also use \texttt{det_univ_to_type/2}, which would throw a runtime error when the type mismatches.

Here is an example program showing how one can implement a form of heterogeneous list with \texttt{univ}:

\begin{lstlisting}[language=Mercury]
:- module ex01.

:- interface.

:- use_module io.
:- pred main(io.state::di, io.state::uo) is det.

:- implementation.

:- import_module string, list, exception, univ.

:- func elem_to_string(univ::in) = (string::out) is det.
elem_to_string(X) = Y :-
    % the `:int`, `:string` and `:float` in the end is necessary.
    % this is used to specify which type you wish to convert the univ
    % value to.
	(univ_to_type(X, XVal:int) -> string.int_to_string(XVal, Y)
	; univ_to_type(X, XVal:string) -> Y = XVal
	; univ_to_type(X, XVal:float) -> string.float_to_string(XVal, Y)
	; throw("Invalid type")
	).

:- pred write_elem_list(list(univ)::in, io.state::di, io.state::uo) is det.
write_elem_list([], !IO).
write_elem_list([X|Xs], !IO) :-
	io.write_string(elem_to_string(X), !IO),
	io.write_string("\n", !IO),
	write_elem_list(Xs, !IO).

main(!IO) :-
	X = [univ("x"), univ(123), univ("y"), univ(456.78)],
	write_elem_list(X, !IO).
\end{lstlisting}

\section{If-Then-Else}

There are two syntaxes for if-then-else:

\begin{lstlisting}[language=Mercury]
% syntax 1:
if [condition]
then [then-clause]
else [else-clause]

% syntax 2:
[condition]
  -> [then-clause]
  ; [else-clause]
\end{lstlisting}

The second one is a carry-over from Prolog.

\section{Defining functions}

By now we have all seen how to define \textit{predicates}: you use the \texttt{:- pred} declaration like this:

\begin{lstlisting}
:- pred pred_name(arg1_type, arg2_type, ..., argn_type).
:- mode pred_name(arg1_mode, arg2_mode, ..., argn_mode) is pred_det.
\end{lstlisting}

For example, we have defined a few predicates in Chapter 2 like this:

\begin{lstlisting}[language=Mercury]
% "string" and "io.state" are types.
% "in", "di" and "uo" are modes.
% "det" is determinism.
:- pred rall(string, string, io.state, io.state).
:- mode rall(in, in, di, uo) is det.
\end{lstlisting}

Sometimes people declare the type signature and the mode signature separately, because in logic programming predicates can work ``in reverse'' and thus would require multiple mode signature. Take the signatures of the predicate \texttt{list.append} for example:

\begin{lstlisting}[language=Mercury]
:- pred append(list(T), list(T), list(T)).
:- mode append(di, di, uo) is det.
:- mode append(in, in, out) is det.
:- mode append(in, in, in) is semidet.    % implied
:- mode append(in, out, in) is semidet.
:- mode append(out, out, in) is multi.
\end{lstlisting}

To explain this line by line:

\begin{itemize}
\item \texttt{list(T)} is a type, where \texttt{T} is a type variable, declaring that it works for any \texttt{list}.
\item The first mode is simply a version of the second one that works on unique inputs.
\item The second mode is for appending two lists together into a third list.
\item The third mode is to check if combining the first two arguments result in the same value as the third argument. The check could succeed or fail, thus having the overall determinism of \texttt{semidet}.
\item The fourth mode is to remove the ``prefix'' (described by the first argument) from the third argument. The third argument might not contain the first one as a prefix, thus having the overall determinism of \texttt{semidet}.
  \item The fifth mode asks the question of ``which two lists can be combined and create the third one''. There obviously must be at least two solutions (exercise: can you figure out why this is the case?) and there could be even more for some input, thus having the overall determinism of \texttt{multi}.
  \end{itemize}


\begin{lstlisting}[language=Mercury]
:- func f_name(arg1type, arg2type, ...) = result_type.
:- mode f_name(arg1mode, arg2mode, ...) = result_mode is f_det.
\end{lstlisting}

  For example, a factorial function might have the following declaration:

\begin{lstlisting}[language=Mercury]
:- func factorial(int) = int.
:- mode factorial(in) = out is det.
\end{lstlisting}

  You also need to write \texttt{f\_name(args) = result} instead of \texttt{f\_name(args, result)} when providing the definition; other than that, the rest is mostly the same. Compare the following two definitions of the factorial function, one defined as a predicate with only one mode, one defined as a function:

\begin{lstlisting}[language=Mercury]
:- pred factorial1(int, int).
:- mode factorial1(in, out) is det.
factorial1(X, Y) :-
	( X =< 1 -> Y = 1
	; ( factorial1(X - 1, Y0),
		Y = X * Y0
	  )
	).

:- func factorial2(int) = int.
:- mode factorial2(in) = out is det.
factorial2(X) = Y :-
  ( X =< 1 -> Y = 1
  ; Y = X * factorial2(X - 1)
  ).
\end{lstlisting}

  Just like predicate declaration, you can combine the type signature and the mode signature in one; and if you do, you need to wrap the return type in parentheses, like this:

\begin{lstlisting}[language=Mercury]
:- func factorial2(int::in) = (int::out) is det.
\end{lstlisting}

  You can technically also declare functions (and predicates) like this, but this is technically not the ``proper'' way. The semantics of this, is to declare the function as a whole is of some higher-order function/predicate type.
  
\begin{lstlisting}[language=Mercury]
:- func factorial2 : (func(int) = int).
\end{lstlisting}

A function, just like a predicate, can have multiple mode declaration. While most (if not all) fucntions we have come across would have their arguments having the mode \texttt{in} and their return value the mode \texttt{out}, but in Mercury, the reverse (i.e. arguments having \texttt{out} and return value having \texttt{in}) is technically possible. See the following example, in which the definition of function \texttt{f1} can be seen as asking the question ``which tuple value can be seen as a result of reversing which tuple's components'':

\begin{lstlisting}[language=Mercury]
:- module ex01.

:- interface.

:- use_module io.
:- pred main(io.state::di, io.state::uo) is det.

:- implementation.
:- import_module int, string.

:- func f1({int, string}) = {string, int}.
:- mode f1(out) = in is det.
f1({X, Y}) = {Y, X}.

:- func first({T1, T2}) = T1.
:- mode first(in) = out is det.
first({X, _}) = X.

main(!IO) :-
	{"abc", 3} = f1(P),
	io.write_string(string.int_to_string(first(P)) ++ "\n", !IO).
\end{lstlisting}


\section{User-defined types}

\subsection{Equivalence types}

The phrase ``equivalence types'' in Mercury refers to what's more commonly known as \textit{type aliases}, i.e. they are types that are defined to be fully equivalent in every way to some other types. This is often done for the sake of code readability, for example:

\begin{lstlisting}[language=Mercury]
:- type money == int.
:- type assoc_list(Key, Value)
        == list(pair(Key, Value)).
\end{lstlisting}

While \texttt{money} and \texttt{assoc\_list(Key, Value)} are equivalent to \texttt{int} and \texttt{list(pair(Key, Value))}, one reading the code would have a basic idea that certain \texttt{int}s are intended for values representing an amount of money and certain \texttt{list}s are intended to be used as an association list. 

(Honestly, the name ``equivalence types'' might bring confusion for people who have a Standard ML background, in which the idea of \textit{equality type} refers to types that one can compare values with \texttt{=} in instead of type aliases, similar to types that have an \texttt{Eq} typeclass constraint in Haskell.)

\subsection{Discriminated unions}

Discriminated union, or ``tagged union'' is a very useful (and thus commonly supported among functional languages) construct. First of all, it can be used to implement what's often called the ``enumerated types'' in other languages. For example:

\begin{lstlisting}[language=Mercury]
:- type days_of_week
        ---> monday
        ;    tuesday
        ;    wednesday
        ;    thursday
        ;    friday
        ;    saturday
        ;    sunday.
\end{lstlisting}

This is not unlike the following in C:

\begin{lstlisting}[language=C]
typedef enum DaysOfWeek {
    MONDAY,
    TUESDAY,
    WEDNESDAY,
    THURSAY,
    FRIDAY,
    SATURDAY,
    SUNDAY,
} DaysOfWeek;
\end{lstlisting}

  The general syntax is as follows. (Note that the arrow here consists of three dashes. Mercury uses 2-dash arrow and 1-dash arrow for other things, so one should be mindful not to mix them up.)
  
\begin{lstlisting}[language=Mercury]
:- type {type_name} --->
        {variant_1} ; {variant_2} ; ... ; {variant_n} .
\end{lstlisting}
  
The core idea of a discriminated union type is exactly how it sounds: it's a union type with a special value (often called a ``tag''; this is also why discriminated unions are also called ``tagged union'') that one uses to discern the different possible forms of the union. For example, you might often see patterns like this in languages like C:

\begin{lstlisting}[language=C]
typedef enum ExprType {
    LIT_INTEGER,
    BIN_OP,
    UNARY_OP,
    FUNC_CALL,
} ExprType;

typedef struct Expr {
    ExprType typ;
    // the ~typ~ field is checked before using the ~value~ field.
    union {
        int lit_int;
        struct { struct Expr *l, *r; char* bop; } bin_op;
        struct { struct Expr *b; char* uop; } un_op;
        struct { char* fun_name; struct Expr* args } func_call;
    } value;
}
\end{lstlisting}

  It can be simply defined in Mercury as follows:

\begin{lstlisting}[language=Mercury]
:- type expr
        ---> lit_integer(int)
        ;    bin_op(expr, expr, string)
        ;    unary_op(expr, string)
        ;    func_call(string, list(expr)).
\end{lstlisting}

  We don't need to have a separate \texttt{:- type exprtype}; the tags are ``built into'' the type \texttt{expr}. When a type is defined this way, these tags are also defined as constructors, i.e. we can obtain a value of \texttt{expr} by simply using the terms \texttt{lit\_integer/1}, \texttt{bin\_op/3}, \texttt{unary\_op/2} or \texttt{func\_call/2}; for example, the term \texttt{lit\_integer(3)} and the term \texttt{bin\_op( lit\_integer(3), lit\_integer(4), "+")} would've automatically determined to have the type of \texttt{expr}.

  To retrieve the different values stored within, we can use unification:

\begin{lstlisting}[language=Mercury]
% ...
SomeVar = some_funcall(some_args),
( ( SomeVar = lit_integer(IntVal),  % ...do something w/ IntVal
  );
  ( SomeVar = bin_op(Left, Right, Op),  % ...do something
  );
  ( SomeVar = unary_op(Body, Op),  % ...do something
  );
  ( SomeVar = func_call(Head, Args),  % ...do something
  )
)
\end{lstlisting}

  This can be tedious at times, especially in cases where you need to have a new value where only some of the fields have changed, in which you have no choice other than reconstructing the term from the ground up once you've defined your data type this way. But - if we choose to use the record syntax, 

\begin{lstlisting}[language=Mercury]
:- type expr
        ---> lit_integer(lit_int :: int)
        ;    bin_op(l :: expr, r :: expr, bop :: string)
        ;    unary_op(b :: expr, uop :: string)
        ;    func_call(fun_name :: string, args :: list(expr)).
\end{lstlisting}

  Certain commonly-used types are actually defined this way. See the definition of lists and key-value lists:

\begin{lstlisting}[language=Mercury]
% in module `list`
:- type list(T)
    --->    []
    ;       [T | list(T)].

% in module `kv_list`
:- type kv_list(K, V)
    --->    kv_nil
    ;       kv_cons(K, V, kv_list(K, V)).
\end{lstlisting}

  Booleans are also defined this way:

\begin{lstlisting}[language=Mercury]
% in module `bool`
:- type bool
    --->    no
    ;       yes.
\end{lstlisting}

\subsection{Abstract types}

Simply put, they are the declarations we've discussed above but without the definition part. These are mainly used in the \texttt{interface} section of a module for the cases where you don't wish to expose the internals of a type to other module:

\begin{lstlisting}[language=Mercury]
:- interface.
:- type t1.
:- type t2(T1, T2).
% ...

:- implementation.
:- type t1 --> % ...
:- type t2(T1, T2) == % ...
% ...
\end{lstlisting}

Of course, you must properly define them in the \texttt{implementation} section of the same module.

\section{Example 1: Interpreter of a small language}

With what we have learned up till now we can now try to write some small programs.

\subsection{The language}

The language we'll be implementing would be a small, imperative one with very basic features like assignment, branching and loops. Its grammar can be described with the following Backus-Naur Form:

\begin{grammar}
  <stmt> ::= IDENT `:=' <expr>
  \alt `IF' <expr> `THEN' <stmt> `ELSE' <stmt>
  \alt `BEGIN' <stmt>* `END'
  \alt `WHILE' <rel> `DO' <stmt>
  \alt `PRINT' <expr>

  <expr> ::= INTEGER
  \alt VAR
  \alt <expr> (`+'|`-'|`*'|`/') <expr>
  \alt (`-') <expr>

  <rel> ::= TRUE
  \alt FALSE
  \alt <expr> (`>'|`<'|`>='|`<='|`!='|`==') <expr>
  \alt <rel> (`\&\&'|`||') <rel>
  \alt `!' <rel>
\end{grammar}

From this BNF we can easily obtain the type definition:

\begin{lstlisting}[language=Mercury]
:- import_module list.
:- type imp_expr
   ---> e_val(int)
   ; e_var(string)
   ; e_binop(string, imp_expr, imp_expr)
   ; e_unaryop(string, imp_expr).
:- type imp_rel
   ---> r_rel(string, imp_expr, imp_expr)
   ; r_binop(string, imp_rel, imp_rel)
   ; r_unaryop(string, imp_rel)
   ; r_true
   ; r_false.
:- type imp_stmt
   ---> s_assign(string, imp_expr)
   ; s_begin(list(imp_stmt))
   ; s_if(imp_rel, imp_stmt, imp_stmt)
   ; s_while(imp_rel, imp_stmt)
   ; s_print(imp_expr).
\end{lstlisting}

We will need a place to store the mapping between the variable names and their corresponding values:

\begin{lstlisting}[language=Mercury]
:- import_module map.
:- type imp_env == map(string, int).
\end{lstlisting}

The evaluation of expression is easy. Since we don't need to update the environment while evaluating expressions for this language, we don't need an extra \texttt{imp_env::out} parameter:

\begin{lstlisting}[language=Mercury]
% needed by `throw`
:- import_module exception.

:- pred imp_eval_expr(imp_expr::in, imp_env::in, int::out) is det.
imp_eval_expr(X, Env, Result) :-
	( X = e_val(XVal), Result = XVal );
	( X = e_var(XVar),
	  ( map__contains(Env, XVar) -> Result = lookup(Env, XVar)
	  ; throw("Cannot found var: " ++ XVar)
	  )
	);
	( X = e_binop(Op, L, R),
	  imp_eval_expr(L, Env, LRes),
	  imp_eval_expr(R, Env, RRes),
	  ( Op = "+" -> Result = LRes + RRes
	  ; Op = "-" -> Result = LRes - RRes
	  ; Op = "*" -> Result = LRes * RRes
	  ; Op = "/" -> Result = LRes div RRes
	  ; throw("Unsupported bin op: " ++ Op)
	  )
	);
	( X = e_unaryop(Op, Body),
	  imp_eval_expr(Body, Env, BRes),
	  ( Op = "-" -> Result = 0 - BRes
	  ; throw("Unsupported unary op: " ++ Op)
	  )
	).
\end{lstlisting}

Evaluating relations, however, requires some not-that-intuitive steps if you choose to first evaluate things into boolean values and dispatch on it. The comparison of numerical values are technically predicate calls, which only succeed or fail instead of producing a value like function calls; if we need a boolean value, we must convert this ``succeed or fail'' state into a boolean value. This is actually very simple, you just do this:

\begin{lstlisting}[language=Mercury]
% the instantiatedness here restricts its argument to those that
% conforms to certain constraints. we will talk about this more
% in the section about instantiatedness.
:- func pred_to_bool( (pred)::in((pred) is semidet) )
       = (bool::out) is det.
pred_to_bool(P) = (if P then yes else no).
\end{lstlisting}

This is available in the standard library by importing the \texttt{bool} module.

Equality check is even more different - when written directly, they're considered as a goal of unification instead a predicate call, which means that we can't even use \texttt{pred_to_bool}. One way to go around this is define a dedicated predicate:

\begin{lstlisting}[language=Mercury]
:- func int_eq(int::in, int::in) = (bool::out) is det.
int_eq(X, Y) = (if X = Y then yes else no).
\end{lstlisting}

With this being available we can define the predicate for evaluating relations like this:

\begin{lstlisting}[language=Mercury]
:- import_module bool.
:- pred imp_eval_rel(imp_rel::in, imp_env::in, bool::out) is det.
imp_eval_rel(X, Env, Result) :-
	( X = r_rel(Op, L, R),
	  imp_eval_expr(L, Env, LRes),
	  imp_eval_expr(R, Env, RRes),
	  ( Op = ">" -> Result = pred_to_bool((RRes < LRes))
	  ; Op = "<" -> Result = pred_to_bool((LRes < RRes))
	  ; Op = "==" -> Result = int_eq(LRes, RRes)
	  ; Op = ">=" -> Result = pred_to_bool((LRes >= RRes))
	  ; Op = "<=" -> Result = pred_to_bool((LRes =< RRes))
	  ; Op = "!=" -> Result = not(int_eq(LRes, RRes))
	  ; throw("Unsupported rel op: " ++ Op)
	  )
	);
	( X = r_binop(Op, L, R),
	  imp_eval_rel(L, Env, LRes),
	  imp_eval_rel(R, Env, RRes),
	  ( Op = "&&" -> Result = and(LRes, RRes)
	  ; Op = "||" -> Result = or(LRes, RRes)
	  ; throw("Unsupported rel op: " ++ Op)
	  )
	);
	( X = r_unaryop(Op, B),
	  imp_eval_rel(B, Env, BRes),
	  ( Op = "!" -> Result = not(BRes)
	  ; throw("Unsupported rel op: " ++ Op)
	  )
	);
	( X = r_true, Result = yes );
	( X = r_false, Result = no ).
\end{lstlisting}

The predicate for executing statements can thus be defined as follows. Evaluating a statement could update the environment (by assignment statements), so we need an \texttt{imp_env::out} to receive the newest version of it:

\begin{lstlisting}[language=Mercury]

:- pred imp_exec_stmt(imp_stmt::in, imp_env::in, imp_env::out) is det.
:- pred imp_exec_stmt_list(list(imp_stmt)::in, imp_env::in, imp_env::out) is det.
:- pred imp_exec_stmt_while(imp_rel::in, imp_stmt::in, imp_env::in, imp_env::out) is det.

imp_exec_stmt(X, Env, NewEnv) :-
	( X = s_assign(Var, Expr),
	  imp_eval_expr(Expr, Env, Val),
	  NewEnv = map__set(Env, Var, Val)
	);
	( X = s_begin(Body),
	  imp_exec_stmt_list(Body, Env, NewEnv)
	);
	( X = s_if(Cond, Then, Else),
	  imp_eval_rel(Cond, Env, CondRes),
	  ( CondRes = yes -> imp_exec_stmt(Then, Env, NewEnv)
	  ; imp_exec_stmt(Else, Env, NewEnv)
	  )
	);
	( X = s_while(Cond, Body),
	  imp_exec_stmt_while(Cond, Body, Env, NewEnv)
	);
	( X = s_print(Expr),
	  imp_eval_expr(Expr, Env, Val),
	  trace [ io(!IO) ] (
		  io__write_int(Val, !IO),
		  io__write_string("\n", !IO)
	  ),
	  NewEnv = Env
	).

imp_exec_stmt_list([], X, X).
imp_exec_stmt_list([X|Xs], Env, NewEnv) :-
	imp_exec_stmt(X, Env, NewEnv1),
	imp_exec_stmt_list(Xs, NewEnv1, NewEnv).

imp_exec_stmt_while(Cond, Body, Env, NewEnv) :-
	imp_eval_rel(Cond, Env, CondRes),
	( CondRes = yes -> (
		  imp_exec_stmt(Body, Env, NewEnv1),
		  imp_exec_stmt_while(Cond, Body, NewEnv1, NewEnv)
	  )
	; NewEnv = Env
	).
\end{lstlisting}

You can tell the Mercury compiler didn't pick up the fact that \texttt{imp_exec_stmt_while} being potentially diverge since its determinism \texttt{det} somehow checks out.

A program in our language is conceptually just a list of statements. We will execute it by calling \texttt{imp_exec_stmt_list} with an empty environment:

\begin{lstlisting}[language=Mercury]
:- pred imp_run(list(imp_stmt)::in) is det.
imp_run(X) :-
	Env = map__init,
	imp_exec_stmt_list(X, Env, _).
\end{lstlisting}

Then we can call it in our \texttt{main}:

\begin{lstlisting}[language=Mercury]
main(!IO) :-
    % X := 100
    % SUM := 0
    % WHILE X > 0 DO
    %     BEGIN
    %         SUM := SUM + X
    %         X := X - 1
    %     END
    % PRINT SUM
	imp_run(
		[
			s_assign("X", e_val(100)),
			s_assign("SUM", e_val(0)),
			s_while(
				r_rel(">", e_var("X"), e_val(0)),
				[
					s_assign("SUM", e_binop("+", e_var("SUM"), e_var("X"))),
					s_assign("X", e_binop("-", e_var("X"), e_val(1)))
				]
			),
			s_print(e_var("SUM"))
		]
	).
\end{lstlisting}

Compile and run the program, and you'll see the number 5050 is printed.

\subsection{Full listing}

\begin{lstlisting}[language=Mercury]
:- module ex01.

:- interface.

:- use_module io.
:- pred main(io.state::di, io.state::uo) is det.

:- implementation.

:- import_module int, string, list, exception, bool, map.

:- type imp_expr
   ---> e_val(int)
   ; e_var(string)
   ; e_binop(string, imp_expr, imp_expr)
   ; e_unaryop(string, imp_expr).
:- type imp_rel
   ---> r_rel(string, imp_expr, imp_expr)
   ; r_binop(string, imp_rel, imp_rel)
   ; r_unaryop(string, imp_rel)
   ; r_true
   ; r_false.
:- type imp_stmt
   ---> s_assign(string, imp_expr)
   ; s_begin(list(imp_stmt))
   ; s_if(imp_rel, imp_stmt, imp_stmt)
   ; s_while(imp_rel, imp_stmt)
   ; s_print(imp_expr).

:- type imp_env == map(string, int).

:- pred imp_eval_expr(imp_expr::in, imp_env::in, int::out) is det.
imp_eval_expr(X, Env, Result) :-
	( X = e_val(XVal), Result = XVal );
	( X = e_var(XVar),
	  ( map__contains(Env, XVar) -> Result = lookup(Env, XVar)
	  ; throw("Cannot found var: " ++ XVar)
	  )
	);
	( X = e_binop(Op, L, R),
	  imp_eval_expr(L, Env, LRes),
	  imp_eval_expr(R, Env, RRes),
	  ( Op = "+" -> Result = LRes + RRes
	  ; Op = "-" -> Result = LRes - RRes
	  ; Op = "*" -> Result = LRes * RRes
	  ; Op = "/" -> Result = LRes div RRes
	  ; throw("Unsupported bin op: " ++ Op)
	  )
	);
	( X = e_unaryop(Op, Body),
	  imp_eval_expr(Body, Env, BRes),
	  ( Op = "-" -> Result = 0 - BRes
	  ; throw("Unsupported unary op: " ++ Op)
	  )
	).

:- func int_eq(int::in, int::in) = (bool::out) is det.
int_eq(X, Y) = (if X = Y then yes else no).

:- pred imp_eval_rel(imp_rel::in, imp_env::in, bool::out) is det.
imp_eval_rel(X, Env, Result) :-
	( X = r_rel(Op, L, R),
	  imp_eval_expr(L, Env, LRes),
	  imp_eval_expr(R, Env, RRes),
	  ( Op = ">" -> Result = pred_to_bool((RRes < LRes))
	  ; Op = "<" -> Result = pred_to_bool((LRes < RRes))
	  % ; Op = "==" -> Result = (LRes, RRes)
	  ; Op = "==" -> Result = int_eq(LRes, RRes)
	  ; Op = ">=" -> Result = pred_to_bool((LRes >= RRes))
	  ; Op = "<=" -> Result = pred_to_bool((LRes =< RRes))
	  ; Op = "!=" -> Result = not(int_eq(LRes, RRes))
	  ; throw("Unsupported rel op: " ++ Op)
	  )
	);
	( X = r_binop(Op, L, R),
	  imp_eval_rel(L, Env, LRes),
	  imp_eval_rel(R, Env, RRes),
	  ( Op = "&&" -> Result = and(LRes, RRes)
	  ; Op = "||" -> Result = or(LRes, RRes)
	  ; throw("Unsupported rel op: " ++ Op)
	  )
	);
	( X = r_unaryop(Op, B),
	  imp_eval_rel(B, Env, BRes),
	  ( Op = "!" -> Result = not(BRes)
	  ; throw("Unsupported rel op: " ++ Op)
	  )
	);
	( X = r_true, Result = yes );
	( X = r_false, Result = no ).

:- pred imp_exec_stmt(imp_stmt::in, imp_env::in, imp_env::out) is det.
:- pred imp_exec_stmt_list(list(imp_stmt)::in, imp_env::in, imp_env::out) is det.
:- pred imp_exec_stmt_while(imp_rel::in, imp_stmt::in, imp_env::in, imp_env::out) is det.

imp_exec_stmt(X, Env, NewEnv) :-
	( X = s_assign(Var, Expr),
	  imp_eval_expr(Expr, Env, Val),
	  NewEnv = map__set(Env, Var, Val)
	);
	( X = s_begin(Body),
	  imp_exec_stmt_list(Body, Env, NewEnv)
	);
	( X = s_if(Cond, Then, Else),
	  imp_eval_rel(Cond, Env, CondRes),
	  ( CondRes = yes -> imp_exec_stmt(Then, Env, NewEnv)
	  ; imp_exec_stmt(Else, Env, NewEnv)
	  )
	);
	( X = s_while(Cond, Body),
	  imp_exec_stmt_while(Cond, Body, Env, NewEnv)
	);
	( X = s_print(Expr),
	  imp_eval_expr(Expr, Env, Val),
	  trace [ io(!IO) ] (
		  io__write_int(Val, !IO),
		  io__write_string("\n", !IO)
	  ),
	  NewEnv = Env
	).

imp_exec_stmt_list([], X, X).
imp_exec_stmt_list([X|Xs], Env, NewEnv) :-
	imp_exec_stmt(X, Env, NewEnv1),
	imp_exec_stmt_list(Xs, NewEnv1, NewEnv).

imp_exec_stmt_while(Cond, Body, Env, NewEnv) :-
	imp_eval_rel(Cond, Env, CondRes),
	( CondRes = yes -> (
		  imp_exec_stmt(Body, Env, NewEnv1),
		  imp_exec_stmt_while(Cond, Body, NewEnv1, NewEnv)
	  )
	; NewEnv = Env
	).

:- pred imp_run(list(imp_stmt)::in) is det.
imp_run(X) :-
	Env = map__init,
	imp_exec_stmt_list(X, Env, _).
	
main(!IO) :-
	imp_run(
		[
			s_assign("X", e_val(100)),
			s_assign("SUM", e_val(0)),
			s_while(
				r_rel(">", e_var("X"), e_val(0)),
				s_begin(
					[
						s_assign("SUM", e_binop("+", e_var("SUM"), e_var("X"))),
						s_assign("X", e_binop("-", e_var("X"), e_val(1)))
					]
				)
			),
			s_print(e_var("SUM"))
		]
	).
\end{lstlisting}

\section{Using multiple modules}

We are going to need this so it's better to talk about it early than late.

\subsection{Basic module usage}

It's probably good measure to go through the basic usage of modules.

There are two ways to import a module:

\begin{itemize}
\item \texttt{import\_module}, which we have been using up till now. Names imported this way do not need to be fully qualified; the module name, when referring to the names defined within, can be omitted until there's ambiguity.
\item \texttt{use\_module}, whose syntax is the same as \texttt{import\_module}, but the names imported this way needs to be fully qualified all the time.
\end{itemize}

Most of the time people would use a period \texttt{.} to separate the module name and the referred name, but Mercury supports using two underscores \texttt{\_\_} as well; for example, instead of calling \texttt{io.write\_string}, you can call \texttt{io\_\_write\_string}.

There is also this thing called ``module-local mutable variable'', which does exactly what it sounds like. However, this feature involves Mercury's purity system, and for that reason we'll talk about it when we get there.


\subsection{Building with multiple modules}

The Melbourne Mercury Compiler comes with two build tools named \texttt{mmake} and \texttt{mmc --make}. The reason why the latter is named \texttt{mmc --make} is because that to use this build tool you do need use the same executable but with a special command line argument. Both covers roughly the same set of features (with an amount of difference in details), both are terribly confusing and under-documented, and both are very confusing. The official documentation recommends \texttt{mmc --make} because ``this is the build tool that is likely to receive more development in the future''. I recommend using \texttt{mmc --make} instead of directly calling \texttt{mmc} because compiling multi-module program with the Melbourne Mercury Compiler is quite complex and not a task that can be achieved by only calling \texttt{mmc}; it's not unlike building a multi-file C project.\footnote{I'd say Mercury might have more hassle than C at this point.} For single-module programs (the ones we have seen till now), you can directly replace \texttt{mmc \lbrack main\_module\rbrack} with \texttt{mmc --bare \lbrack main\_module\rbrack} (e.g. \texttt{mmc --make rall.m} instead of \texttt{mmc rall.m}). For multi-module programs, you can also use \texttt{mmc --make \lbrack entry\rbrack} and expect it to handle module dependencies automatically and give you an executable without much errors.

\subsection{Submodules}

There are times when you'd like to group certain things within a module into its own subgroup; in Mercury this can be achieved by defining a submodule. There are two kinds of submodule in Mercury: ones that are defined and embedded within the ``main'' module, and ones that are in a separate file. For the former ones, you do it like this:

\begin{lstlisting}[language=Mercury]
:- module main_module.
:- interface.

:- module submod.
:- interface.
    % submod interface goes here.
:- end_module submod.

:- implementation.

:- module submod.
:- implementation.
    % submod implementation goes here.
:- end_module submod.
% ...
\end{lstlisting}

Naturally, if you don't want the definition of \texttt{submod} being visible from the outside, you put its interface section in the declaration of the parent module's implementation section; but to put the implementation section of a nested submodule in the interface section of the parent module is forbidden.

If you want to put the definition of the submodule in a separate file, you must do the following:

\begin{itemize}
\item The content of that submodule must be in a file with the file name being the fully qualified name of the submodule (e.g. the source for the submodule \texttt{submod} of the parent module \texttt{mainmod1} must be put in the file with the name \texttt{mainmod1.submod.m}). (Using a different module name is possible; see the next section.)
\item Add an \texttt{include\_module} declaration in the parent module, like this:
\begin{lstlisting}[language=Mercury]
:- module parent_module.
:- interface.
:- include_module submod1, submod2, ..., submod_n.
\end{lstlisting}
\end{itemize}

Either way, having the definition of the submodule doesn't mean the names within the submodule is immediately available within the parent module; you still need to import the submodule explicitly if you want to use it.


\subsection{Using a different module name}

Normally module names should match with the name of the file; but if you insist on using a different name, the Mercury compiler would need to know which name corresponds to which file. The compiler would expect this information in a file named \texttt{Mercury.modules} residing in the same directory as the module that uses the name-mismatch module. The \texttt{mmc} command provides a flag to generate this file: to check all the modules within a directory and generate the \texttt{Mercury.modules}, run \texttt{mmc -f}. This file can technically be modified so that the build tool would use modules located at other places; one may manage different libraries a project might use this way, but I'm not sure this is part of the intended usage.

\section{Exception handling}

We already know that we can throw exceptions using \texttt{throw/1}. Now we learn how to handle them.

\subsection{Handling with predicates}

A few predicates have been provided in the \texttt{exception} module:\footnote{There are other predicates, which have slightly more niche usage so we will not cover them here.}

\begin{itemize}
\item \texttt{try(Goal, Result)}: . \texttt{Result} [].
\item \texttt{try_io(Goal, Result, !IO)}: Same as \texttt{try/2}, but with extra parameters for IO.
\item \texttt{try_all(Goal, MaybeException, Solution)}: Collect all solutions of \texttt{Goal} which might throw exceptions into \texttt{Solution}. \texttt{MaybeException} would be bound with a value of type \texttt{maybe(univ)}; if an exception did get thrown, that \texttt{maybe} value would contain that exception; and if there has been no exception, it would simply be an empty value.
  \item \texttt{finally(Goal, Res, Cleanup, CleanupRes, !IO)}:
\end{itemize}

\section{Advanced goals}

Up till now we have seen the following forms of goals:

\begin{itemize}
\item Conjunction, written as \texttt{A, B};
\item Disjunction, written as \texttt{A; B};
\item Branching, written as \texttt{if Cond then A else B} or \texttt{(Cond -> A; B)};
\item Unification, written as \texttt{A = B};
  \item Trace goals, written as \texttt{trace [Args] Goal};
\end{itemize}

Fact is, there is much more than the one listed above. We will go through a few more of them in this section. 

\subsection{Other basic goals}

\begin{itemize}
\item Success, written as \texttt{true}, is a goal that always succeed.
\item Failure, written as \texttt{fail}, is a goal that always fail.
\item Negation is written as \texttt{not Goal} or \texttt{\textbackslash + Goal}.
\item Inequality, which is written as \texttt{A \= B}. This is equivalent to \texttt{not (A = B)}.
  \item Parallel conjunction, written as \texttt{A \& B}, is a goal that executes both \texttt{A} and \texttt{B} in parallel. The actual behaviour depends on the backend (called ``grade'' in Mercury lingo), and in certain cases might act like normal conjunction. Both \texttt{A} and \texttt{B} must be either of determinism \texttt{det} or \texttt{cc_multi}.
\end{itemize}

\subsection{Existential quantification}

Within the same clause of the definition of a predicate/function, all variables share the same scope; for example, in the snippet below, variables \texttt{N}, \texttt{M} and \texttt{M1} all share the same scope; new variables within this clause are thus required to not share the same name:

\begin{lstlisting}[language=Mercury]
fac(N, M) :-
	( if ( N = 0 ) then ( M = 1 )
	  else if ( N = 1 ) then ( M = 1 )
	  else if ( N < 0 ) then ( M = 1 )
	  else ( fac(N-1, M1), M = N * M1 )
	).
\end{lstlisting}

Sometimes this might prove to be bothersome, especially in predicates that are more substantial. In this case, one might want to have separate scopes, where one can reuse certain variable names as if they have never been used. One can achieve this by using existential quantification, written as \texttt{some [Vars] Goal}; all variables declared in \texttt{[Vars]} can be used without fear within \texttt{Goal}. For example:

\begin{lstlisting}[language=Mercury]
main(!IO) :-
	X = 3,
	some [X] (
		X = "blah\n",
		io.write_string(X, !IO)
	),
	io.write_int(X, !IO).
\end{lstlisting}

This would compile without error (albeit the compiler would produce a warning complaining about \texttt{X} being reused) despite the variable \texttt{X} being bound to values of different types.

Technically all normal goals are implicitly existential quantified; making them explicit won't introduce any change in semantics and/or actual behaviour.

Mercury also support universal quantification goals, which are of the form \texttt{all [Vars] Goal} and are equivalent to \texttt{not (some [Vars] (not Goal))}.

\subsection{Shorthands for certain compound goals}

\begin{itemize}
\item Implication: \texttt{A => B}, which is equivalent to \texttt{not (A, not B)}.
\item Reverse implication: \texttt{A <= B}, which is equivalent to \texttt{B => A}, which is in turn equivalent to \texttt{not (B, not A)}.
  \item Logical equivalence: \texttt{A <=> B}, which is equivalent to \texttt{(A => B), (B => A)}
\end{itemize}

\section{Higher-order programming}


\section{Working with other people's libraries}

%%% Local Variables:
%%% mode: LaTeX
%%% TeX-master: "../main"
%%% End:
